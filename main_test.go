package main

import "testing"

func Same(s1, s2 *[][]int) bool {
	if len(*s1) == 0 && len(*s2) == 0 {
		return true
	}
	if len(*s1) != len(*s2) || len((*s1)[0]) != len((*s2)[0]) {
		return false
	}
	for i := 0; i < len(*s1); i++ {
		for j := 0; j < len((*s1)[0]); j++ {
			if (*s1)[i][j] != (*s2)[i][j] {
				return false
			}
		}
	}
	return true
}

func TestSame(t *testing.T) {
	type Input struct {
		s1, s2 [][]int
	}
	for _, tc := range []struct {
		input Input
		want  bool
	}{
		{Input{nil, nil}, true},
		{Input{[][]int{}, [][]int{}}, true},
		{Input{[][]int{
			{1, 2, 3},
			{1, 2, 3},
			{1, 2, 3},
		}, [][]int{
			{1, 2, 3},
			{1, 2, 3},
			{1, 2, 3},
		}}, true},
		{Input{[][]int{
			{1, 2, 3},
			{1, 2, 3},
			{1, 2, 3},
		}, [][]int{
			{3, 2, 1},
			{3, 2, 1},
			{3, 2, 1},
		}}, false},
		{Input{[][]int{
			{1, 2, 3},
			{1, 2, 3},
			{1, 2, 3},
		}, [][]int{
			{1, 2, 3},
			{1, 2, 3},
		}}, false},
		{Input{[][]int{
			{1, 1},
			{1, 1},
			{1, 1},
			{1, 1},
		}, [][]int{
			{1, 1},
			{1, 1},
			{1, 1},
			{1, 1},
		}}, true},
	} {
		if got := Same(&tc.input.s1, &tc.input.s2); got != tc.want {
			t.Errorf("got = %v, want = %v", got, tc.want)
		}
	}
}

func TestFlipMaze(t *testing.T) {
	for _, tc := range []struct {
		input [][]int
		want  [][]int
	}{
		{nil, nil},
		{[][]int{}, [][]int{}},
		{[][]int{
			{1, 1, 1, 1, 1},
			{1, 0, 0, 0, 1},
			{1, 0, 0, 0, 1},
			{1, 9, 0, 0, 1},
			{2, 1, 1, 1, 1},
		}, [][]int{
			{2, 1, 1, 1, 1},
			{1, 9, 0, 0, 1},
			{1, 0, 0, 0, 1},
			{1, 0, 0, 0, 1},
			{1, 1, 1, 1, 1},
		}},
		{[][]int{
			{1, 1, 1},
			{1, 0, 1},
			{1, 9, 1},
			{1, 1, 1},
		}, [][]int{
			{1, 1, 1},
			{1, 9, 1},
			{1, 0, 1},
			{1, 1, 1},
		}},
		{[][]int{
			{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
			{1, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
			{1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
			{1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1},
			{1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1},
			{1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1},
			{1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1},
			{1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1},
			{1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1},
			{1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1},
			{1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1},
			{1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
			{1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
			{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
		}, [][]int{
			{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
			{1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
			{1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
			{1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1},
			{1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1},
			{1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1},
			{1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1},
			{1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1},
			{1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1},
			{1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1},
			{1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1},
			{1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
			{1, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
			{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
		}},
	} {
		var got [][]int = tc.input
		if FlipVertically(&got); !Same(&got, &tc.want) {
			t.Errorf("got = %v, want = %v", got, tc.want)
		}
	}
}

// TODO: Test swap
// TODO: Write and Test Maze condition check(walls around)
